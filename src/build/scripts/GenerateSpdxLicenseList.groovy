
/* A script to generate SpdxLicenseListData */

import java.nio.file.Path
import java.nio.file.Files
import java.util.regex.Pattern
import java.util.AbstractMap.SimpleImmutableEntry
import groovy.json.JsonSlurper
import groovy.transform.Field
import org.apache.commons.codec.digest.DigestUtils
import org.apache.http.HttpEntity;
import org.apache.http.impl.client.CloseableHttpClient
import org.apache.http.impl.client.HttpClients
import org.apache.http.client.config.RequestConfig
import org.apache.http.client.config.RequestConfig.Builder
import org.apache.http.client.methods.CloseableHttpResponse
import org.apache.http.client.methods.HttpGet
import org.apache.http.entity.ContentType;
import org.apache.http.HttpStatus
import org.apache.http.StatusLine
import org.slf4j.LoggerFactory

def log = LoggerFactory.getLogger(this.class)
@Field UrlChecker urlChecker

final Path basePath = basedir.toPath()

final URL licensesUrl = new URL('https://raw.githubusercontent.com/spdx/license-list-data/master/json/licenses.json')
final Path spdxDir = basePath.resolve('src/main/java/org/codehaus/mojo/license/spdx')
final Path spdxTestDir = basePath.resolve('src/test/java/org/codehaus/mojo/license/spdx')
/* Licenses known to deliver different content over time, although they pass out simple test here */
final List<Pattern> instableContentUrls = [ Pattern.compile('.*opensource\\.org.*') ]

def engine = new groovy.text.SimpleTemplateEngine()
JsonSlurper jsonSlurper = new JsonSlurper()
Map<String, Object> spdx = jsonSlurper.parseText(licensesUrl.text)
try {
    urlChecker = new UrlChecker(instableContentUrls)

    spdx['licenses'].each { lic ->
        log.info("Starting "+ lic['licenseId'])
        lic['seeAlso']?.each { url ->
            url = url.trim()
            urlChecker.addUrl(url)
        }
    }
    log.info("Rechecking")
    urlChecker.recheck()

    def model = [
        spdx: spdx,
        year: Calendar.getInstance().get(Calendar.YEAR),
        urlChecker: urlChecker
    ]

    def sourceTemplate = '''package org.codehaus.mojo.license.spdx;

/*
 * #%L
 * License Maven Plugin
 * %%
 * Copyright (C) ${year} Codehaus
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 *
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-3.0.html>.
 * #L%
 */

/**
 * A class generated by GenerateSpdxLicenseList.groovy from
 * <a href="https://raw.githubusercontent.com/spdx/license-list-data/master/json/licenses.json">
 * https://raw.githubusercontent.com/spdx/license-list-data/master/json/licenses.json</a>
 */
class SpdxLicenseListData
{

    static SpdxLicenseList createList()
    {
        final SpdxLicenseList.Builder builder = SpdxLicenseList.builder();
<%
spdx.each { field, value ->
    switch (field) {
    case 'licenseListVersion':
    case 'releaseDate':
        println '        builder.' + field + '( "' + value + '" );'
        break
    case 'licenses':
        value.each { lic ->
            println ""
            println "        builder.license( SpdxLicenseInfo.builder()"
            lic.each { licField, licValue ->
                switch (licField) {
                    case 'isDeprecatedLicenseId':
                    case 'referenceNumber':
                    case 'isOsiApproved':
                    case 'isFsfLibre':
                        println '            .' + licField + '( ' + licValue + ' )'
                        break
                    case 'detailsUrl':
                    case 'name':
                    case 'reference':
                    case 'licenseId':
                        println '            .' + licField + '( "' + licValue.trim().replace('"', '\\\\" ') + '" )'
                        break
                    case 'seeAlso':
                        licValue.each { seeAlso ->
                            final String url = seeAlso.trim()
                            println '            .seeAlso( "' + url.replace('"', '\\\\"') + '" )'
                        }
                        def urlInfos = urlChecker.getUrlInfos(licValue);
                        if (!urlInfos.isEmpty()) {
                            println ''
                            urlInfos.each { url, sha1MimeTypeStable ->
                                final String sha1 = sha1MimeTypeStable.get(0)  == null ? 'null' : ('"' + sha1MimeTypeStable.get(0) + '"')
                                final String mimeType = sha1MimeTypeStable.get(1)  == null ? 'null' : ('"' + sha1MimeTypeStable.get(1) + '"')
                                println '            .urlInfo( "' + url + '", ' + sha1 + ', ' + mimeType + ', ' + sha1MimeTypeStable.get(2) + ' )'
                            }
                        }
                        break
                    default:
                        throw new IllegalStateException( "Unexpected field of SPDX license "+ licField )
                }
            }
            println "            .build()"
            println "        );"
        }
        println ""
        break
    default:
        throw new IllegalStateException( "Unexpected field of SPDX license list "+ field )
    }
}
%>        return builder.build();
    }
}
'''
    String source = engine.createTemplate(sourceTemplate).make(model)
    spdxDir.resolve("SpdxLicenseListData.java").toFile().write(source)


def testTemplate = '''package org.codehaus.mojo.license.spdx;

/*
 * #%L
 * License Maven Plugin
 * %%
 * Copyright (C) ${year} Codehaus
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 *
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-3.0.html>.
 * #L%
 */

/**
 * A class generated by GenerateSpdxLicenseList.groovy from
 * <a href="https://raw.githubusercontent.com/spdx/license-list-data/master/json/licenses.json">
 * https://raw.githubusercontent.com/spdx/license-list-data/master/json/licenses.json</a>
 */
public class SpdxLicenseListDataTest
{
    @org.junit.Test
    public void getInstance()
    {
        SpdxLicenseList list = SpdxLicenseList.getLatest();
        org.junit.Assert.assertEquals( ${spdx.licenses.size()}, list.getLicenses().size() );
    }
}
'''

    String testSource = engine.createTemplate(testTemplate).make(model)
    Files.createDirectories(spdxTestDir)
    spdxTestDir.resolve("SpdxLicenseListDataTest.java").toFile().write(testSource)

} finally {
    urlChecker?.close()
}

class UrlChecker implements AutoCloseable {
    def log = LoggerFactory.getLogger(this.class)
    private final Map<String, Set<String>> sha1ToUrls = new LinkedHashMap<>()
    private final Map<String, Map.Entry<String, String>> urlToSha1MimeType = new LinkedHashMap<>()
    private final CloseableHttpClient client
    private final List<Pattern> instableContentUrls

    public UrlChecker(List<Pattern> instableContentUrls) {
        this.instableContentUrls = instableContentUrls
        final RequestConfig config = RequestConfig.copy(RequestConfig.DEFAULT)
                .setConnectTimeout(2000)
                .setSocketTimeout(2000)
                .setConnectionRequestTimeout(2000)
                .build();
        this.client = HttpClients.custom().setDefaultRequestConfig(config).build()
    }

    public void addUrl(String url) {
        if (!urlToSha1MimeType.containsKey(url)) {
            urlToSha1MimeType.put(url, get(url))
        }
    }

    public void recheck() {
        final Set<Map.Entry<String, Map.Entry<String, String>>> newUrlToSha1MimeType = new LinkedHashSet<>();
        final Iterator<Map.Entry<String, Map.Entry<String, String>>> it = urlToSha1MimeType.entrySet().iterator()
        while (it.hasNext()) {
            final Map.Entry<String, Map.Entry<String, String>> old = it.next()
            final String url = old.getKey()
            final Map.Entry<String, String> oldSha1MimeType = old.getValue()
            if (oldSha1MimeType != null) {
                final Map.Entry<String, String> newSha1 = get(url)
                if (!oldSha1MimeType.equals(newSha1)) {
                    log.warn("Volatile content from URL: "+ url)
                    old.setValue(new SimpleImmutableEntry(null, oldSha1MimeType.getValue()))
                } else {
                    generalize(url, oldSha1MimeType.getKey(), newUrlToSha1MimeType)
                }
            } else {
                //it.remove()
            }
        }
        for (Map.Entry<String, Map.Entry<String, String>> newEntry in newUrlToSha1MimeType) {
            urlToSha1MimeType.put(newEntry.getKey(), newEntry.getValue())
        }
    }

    // @return sha1, mimeType pair
    private Map.Entry<String, String> get(String url) {
        CloseableHttpResponse response;
        try {
            response = client.execute( new HttpGet( url ) )
            final StatusLine statusLine = response.getStatusLine();
            if ( statusLine.getStatusCode() != HttpStatus.SC_OK )
            {
                log.warn("Got "+ statusLine + " for "+ url)
                return null;
            }
            log.info("Got "+ statusLine.getStatusCode() + " for "+ url)
            final HttpEntity entity = response.getEntity();
            if ( entity != null )
            {
                final ContentType contentType = ContentType.get( entity );
                final String mimeType = contentType != null ? contentType.getMimeType() : null
                InputStream is = null
                try {
                    is = entity.getContent()
                    final String sha1 = DigestUtils.sha1Hex(is)
                    return new SimpleImmutableEntry(sha1, mimeType)
                }
                finally {
                    is?.close()
                }
            } else {
                log.warn("Got no body for "+ url)
                return null;
            }
        } catch (Exception e) {
            log.warn("Could not get "+ url +": "+ e.getMessage())
            return null;
        } finally {
            response?.close()
        }
    }

    public Map<String, Tuple> getUrlInfos(List<String> urls) {
        final Map<String, Tuple> result = new LinkedHashMap<>()
        for (String url in urls) {
            url = url.trim()
            final boolean stable = isStable(url)
            final Map.Entry<String, String> sha1MimeType = urlToSha1MimeType.get(url)
            if (sha1MimeType != null) {
                if (sha1MimeType.getKey() != null) {
                    final Set<String> sha1Urls = sha1ToUrls.get(sha1MimeType.getKey())
                    assert sha1Urls != null
                    assert !sha1Urls.isEmpty()
                    for (String shaUrl in sha1Urls) {
                        Map.Entry<String, String> smt = urlToSha1MimeType.get(shaUrl)
                        assert smt != null
                        final String sha1 = smt.getKey()
                        result.put(shaUrl, new Tuple(sha1, smt.getValue(), sha1 != null && stable))
                    }
                } else {
                    result.put(url, new Tuple(null, null, false))
                }
            }
        }
        return result;
    }

    public Map.Entry<String, String> getSha1MimeType(String url) {
        return urlToSha1MimeType.get(url);
    }

    private void tryAdd(String url, String sha1, Set<String> urls, Set<Map.Entry<String, Map.Entry<String, String>>> newUrlToSha1MimeType) {
        if (!urls.contains(url)) {
            final Map.Entry<String, String> newSha1MimeType = get(url)
            if (sha1.equals(newSha1MimeType?.getKey())) {
                log.info(" - generalized: "+ url)
                urls.add(url)
                newUrlToSha1MimeType.add(new SimpleImmutableEntry(url, new SimpleImmutableEntry(sha1, newSha1MimeType.getValue())))
            }
        }
    }

    private boolean isStable(String url) {
        for (Pattern pat in instableContentUrls) {
            if (pat.matcher(url).matches()) {
                return false
            }
        }
        return true
    }

    public void generalize(String url, String sha1, Set<Map.Entry<String, Map.Entry<String, String>>> newUrlToSha1MimeType) {
        log.info("Generalizing "+ url)
        final Set<String> urls = sha1ToUrls.get(sha1)
        if (urls == null) {
            urls = new TreeSet<>()
            sha1ToUrls.put(sha1, urls)
        }
        urls.add(url)
        if (url.startsWith('http://')) {
            if (url.indexOf('://www.') >= 0) {
                tryAdd(url.replace('http://', 'https://'), sha1, urls, newUrlToSha1MimeType);
                tryAdd(url.replace('://www.', '://'), sha1, urls, newUrlToSha1MimeType);
                tryAdd(url.replace('http://', 'https://').replace('://www.', '://'), sha1, urls, newUrlToSha1MimeType);
            } else {
                tryAdd(url.replace('http://', 'https://'), sha1, urls, newUrlToSha1MimeType);
                tryAdd(url.replace('://', '://www.'), sha1, urls, newUrlToSha1MimeType);
                tryAdd(url.replace('http://', 'https://').replace('://', '://www.'), sha1, urls, newUrlToSha1MimeType);
            }
        } else if (url.startsWith('https://')) {
            if (url.indexOf('://www.') >= 0) {
                tryAdd(url.replace('https://', 'http://'), sha1, urls, newUrlToSha1MimeType);
                tryAdd(url.replace('://www.', '://'), sha1, urls, newUrlToSha1MimeType);
                tryAdd(url.replace('https://', 'http://').replace('://www.', '://'), sha1, urls, newUrlToSha1MimeType);
            } else {
                tryAdd(url.replace('https://', 'http://'), sha1, urls, newUrlToSha1MimeType);
                tryAdd(url.replace('://', '://www.'), sha1, urls, newUrlToSha1MimeType);
                tryAdd(url.replace('https://', 'http://').replace('://', '://www.'), sha1, urls, newUrlToSha1MimeType);
            }
        }
    }

    public void close() throws IOException {
        client.close();
    }
}

